import numpy as np
import cv2
from google.colab.patches import cv2_imshow

# img = np.array([
#     [10, 10, 10, 10, 10],
#     [10, 10, 50, 10, 10],
#     [10, 50, 255, 50, 10],
#     [10, 10, 50, 10, 10],
#     [10, 10, 10, 10, 10]
# ], dtype=float)


img = cv2.imread('CV_Image.jpg', cv2.IMREAD_GRAYSCALE)


def gaussian_blur(image):

    return cv2.GaussianBlur(image, (5, 5), 1.4)

def compute_gradients(image):
    gx = cv2.Sobel(image, cv2.CV_64F, 1, 0, ksize=3)
    gy = cv2.Sobel(image, cv2.CV_64F, 0, 1, ksize=3)

    magnitude = np.sqrt(gx**2 + gy**2)
    direction = np.arctan2(gy, gx) * 180 / np.pi

    direction[direction < 0] += 180

    return magnitude, direction

def non_maximum_suppression(magnitude, direction):
    rows, cols = magnitude.shape
    suppressed = np.zeros_like(magnitude, dtype=np.float64)

    for i in range(1, rows-1):
        for j in range(1, cols-1):
            angle = direction[i, j]
            mag = magnitude[i, j]

            if (0 <= angle < 22.5) or (157.5 <= angle <= 180):
                q, r = magnitude[i, j+1], magnitude[i, j-1]
            elif 22.5 <= angle < 67.5:
                q, r = magnitude[i-1, j+1], magnitude[i+1, j-1]
            elif 67.5 <= angle < 112.5:
                q, r = magnitude[i-1, j], magnitude[i+1, j]
            elif 112.5 <= angle < 157.5:
                q, r = magnitude[i-1, j-1], magnitude[i+1, j+1]
            else:
                q, r = -1, -1

            if mag >= q and mag >= r:
                suppressed[i, j] = mag
    return suppressed

def double_thresholding(magnitude, low_threshold=50, high_threshold=150):
    rows, cols = magnitude.shape
    edges = np.zeros_like(magnitude, dtype=np.uint8)

    strong_i, strong_j = np.where(magnitude >= high_threshold)
    weak_i, weak_j = np.where((magnitude < high_threshold) & (magnitude >= low_threshold))

    edges[strong_i, strong_j] = 255
    edges[weak_i, weak_j] = 50

    return edges

def hysteresis(edges):
    rows, cols = edges.shape
    final_edges = np.copy(edges)

    neighbors = [(i, j) for i in [-1, 0, 1] for j in [-1, 0, 1] if (i != 0 or j != 0)]

    weak_edge_queue = []
    for i in range(1, rows - 1):
      for j in range(1, cols - 1):
        if final_edges[i, j] == 50:
          weak_edge_queue.append((i, j))

    while weak_edge_queue:
      i, j = weak_edge_queue.pop(0)
      for di, dj in neighbors:
          ni, nj = i + di, j + dj
          if 0 <= ni < rows and 0 <= nj < cols and final_edges[ni, nj] == 255:
              final_edges[i, j] = 255
              break
    final_edges[final_edges == 50] = 0

    return final_edges

image_float = img.astype(float)

print("Original Image:")
cv2_imshow(img)

blurred = gaussian_blur(image_float)
magnitude, direction = compute_gradients(blurred)
suppressed = non_maximum_suppression(magnitude, direction)
thresholded = double_thresholding(suppressed, low_threshold=50, high_threshold=100)

final_edges = hysteresis(thresholded)
print("Final Edge Map:")
cv2_imshow(final_edges)
